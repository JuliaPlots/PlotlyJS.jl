<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Docs · PlotlyJS</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="https://cdn.plot.ly/plotly-1.54.7.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PlotlyJS</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../basics/">Preliminaries</a></li><li><a class="tocitem" href="../building_traces_layouts/">Building Blocks</a></li><li><a class="tocitem" href="../syncplots/">Putting it together</a></li><li><a class="tocitem" href="../manipulating_plots/">Working with plots</a></li><li><a class="tocitem" href="../styles/">Styles</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/3d/">3d</a></li><li><a class="tocitem" href="../examples/area/">Area</a></li><li><a class="tocitem" href="../examples/bar/">Bar</a></li><li><a class="tocitem" href="../examples/box_plots/">Box Plots</a></li><li><a class="tocitem" href="../examples/contour/">Contour</a></li><li><a class="tocitem" href="../examples/finance/">Financial Charts</a></li><li><a class="tocitem" href="../examples/heatmaps/">Heatmaps</a></li><li><a class="tocitem" href="../examples/histograms/">Histograms</a></li><li><a class="tocitem" href="../examples/line_scatter/">Line and Scatter</a></li><li><a class="tocitem" href="../examples/maps/">Maps</a></li><li><a class="tocitem" href="../examples/shapes/">Shapes</a></li><li><a class="tocitem" href="../examples/subplots/">Subplots</a></li><li><a class="tocitem" href="../examples/tables/">Tables</a></li><li><a class="tocitem" href="../examples/ternary/">Ternary</a></li><li><a class="tocitem" href="../examples/time_series/">Time Series</a></li><li><a class="tocitem" href="../examples/violin/">Violin</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Docs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Docs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPlots/PlotlyJS.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{Plot}" href="#Base.size-Tuple{Plot}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(::PlotlyBase.Plot)</code></pre><p>Return the size of the plot in pixels. Obtained from the <code>layout.width</code> and <code>layout.height</code> fields.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.addtraces!-Tuple{Plot,Int64,Vararg{AbstractTrace,N} where N}" href="#PlotlyBase.addtraces!-Tuple{Plot,Int64,Vararg{AbstractTrace,N} where N}"><code>PlotlyBase.addtraces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addtraces!(p::Plot, i::Int, traces::AbstractTrace...)</code></pre><p>Add trace(s) at a specified location in the Plot&#39;s array of data.</p><p>The new traces will start at index <code>p.data[i]</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.addtraces!-Tuple{Plot,Vararg{AbstractTrace,N} where N}" href="#PlotlyBase.addtraces!-Tuple{Plot,Vararg{AbstractTrace,N} where N}"><code>PlotlyBase.addtraces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addtraces!(p::Plot, traces::AbstractTrace...)</code></pre><p>Add trace(s) to the end of the Plot&#39;s array of data</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.circle" href="#PlotlyBase.circle"><code>PlotlyBase.circle</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Draw a circle from ((<code>x0</code>+<code>x1</code>)/2, (<code>y0</code>+<code>y1</code>)/2)) with radius  (|(<code>x0</code>+<code>x1</code>)/2 - <code>x0</code>|, |(<code>y0</code>+<code>y1</code>)/2 -<code>y0</code>)|) </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.deletetraces!-Tuple{Plot,Vararg{Int64,N} where N}" href="#PlotlyBase.deletetraces!-Tuple{Plot,Vararg{Int64,N} where N}"><code>PlotlyBase.deletetraces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deletetraces!(p::Plot, inds::Int...) =</code></pre><p>Remove the traces at the specified indices</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.extendtraces!" href="#PlotlyBase.extendtraces!"><code>PlotlyBase.extendtraces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">extendtraces!(::Plot, ::Dict{Union{Symbol,AbstractString},AbstractVector{Vector{Any}}}), indices, maxpoints)</code></pre><p>Extend one or more traces with more data. A few notes about the structure of the update dict are important to remember:</p><ul><li>The keys of the dict should be of type <code>Symbol</code> or <code>AbstractString</code> specifying the trace attribute to be updated. These attributes must already exist in the trace</li><li>The values of the dict <em>must be</em> a <code>Vector</code> of <code>Vector</code> of data. The outer index tells Plotly which trace to update, whereas the <code>Vector</code> at that index contains the value to be appended to the trace attribute.</li></ul><p>These concepts are best understood by example:</p><pre><code class="language-julia"># adds the values [1, 3] to the end of the first trace&#39;s y attribute and doesn&#39;t
# remove any points
extendtraces!(p, Dict(:y=&gt;Vector[[1, 3]]), [1], -1)
extendtraces!(p, Dict(:y=&gt;Vector[[1, 3]]))  # equivalent to above</code></pre><pre><code class="language-julia"># adds the values [1, 3] to the end of the third trace&#39;s marker.size attribute
# and [5,5,6] to the end of the 5th traces marker.size -- leaving at most 10
# points per marker.size attribute
extendtraces!(p, Dict(&quot;marker.size&quot;=&gt;Vector[[1, 3], [5, 5, 6]]), [3, 5], 10)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.hline" href="#PlotlyBase.hline"><code>PlotlyBase.hline</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hline(y, fields::AbstractDict=Dict{Symbol,Any}(); kwargs...)</code></p><p>Draw horizontal lines at each point in <code>y</code> that span the width of the plot</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.line" href="#PlotlyBase.line"><code>PlotlyBase.line</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Draw a line through the points (x0, y0) and (x1, y2)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.movetraces!-Tuple{Plot,AbstractArray{Int64,1},AbstractArray{Int64,1}}" href="#PlotlyBase.movetraces!-Tuple{Plot,AbstractArray{Int64,1},AbstractArray{Int64,1}}"><code>PlotlyBase.movetraces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">movetraces!(p::Plot, src::AbstractVector{Int}, dest::AbstractVector{Int})</code></pre><p>Move traces from indices <code>src</code> to indices <code>dest</code>.</p><p>Both <code>src</code> and <code>dest</code> must be <code>Vector{Int}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.movetraces!-Tuple{Plot,Vararg{Int64,N} where N}" href="#PlotlyBase.movetraces!-Tuple{Plot,Vararg{Int64,N} where N}"><code>PlotlyBase.movetraces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">movetraces!(p::Plot, to_end::Int...)</code></pre><p>Move one or more traces to the end of the data array&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.path-Tuple{AbstractString}" href="#PlotlyBase.path-Tuple{AbstractString}"><code>PlotlyBase.path</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Draw an arbitrary svg path</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.prependtraces!" href="#PlotlyBase.prependtraces!"><code>PlotlyBase.prependtraces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prependtraces!(p::Plot, update::AbstractDict, indices::AbstractVector{Int}=[1],
                maxpoints=-1)</code></pre><p>The API for <code>prependtraces</code> is equivalent to that for <code>extendtraces</code> except that the data is added to the front of the traces attributes instead of the end. See Those docstrings for more information</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.rect" href="#PlotlyBase.rect"><code>PlotlyBase.rect</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Draw a rectangle linking (<code>x0</code>,<code>y0</code>), (<code>x1</code>,<code>y0</code>), (<code>x1</code>,<code>y1</code>), (<code>x0</code>,<code>y1</code>), (<code>x0</code>,<code>y0</code>)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.relayout!" href="#PlotlyBase.relayout!"><code>PlotlyBase.relayout!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relayout!(l::Layout, update::AbstractDict=Dict(); kwargs...)</code></pre><p>Update <code>l</code> using update dict and/or kwargs</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.relayout!-Tuple{Plot,Vararg{Any,N} where N}" href="#PlotlyBase.relayout!-Tuple{Plot,Vararg{Any,N} where N}"><code>PlotlyBase.relayout!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relayout!(p::Plot, update::AbstractDict=Dict(); kwargs...)</code></pre><p>Update <code>p.layout</code> on using update dict and/or kwargs</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.restyle!" href="#PlotlyBase.restyle!"><code>PlotlyBase.restyle!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The <code>restyle!</code> method follows the semantics of the <code>Plotly.restyle</code> function in plotly.js. Specifically the following rules are applied when trying to set an attribute <code>k</code> to a value <code>v</code> on trace <code>ind</code>, which happens to be the <code>i</code>th trace listed in the vector of <code>ind</code>s (if <code>ind</code> is a scalar then <code>i</code> is always equal to 1)</p><ul><li>if <code>v</code> is an array or a tuple (both translated to javascript arrays when</li></ul><p><code>json(v)</code> is called) then <code>p.data[ind][k]</code> will be set to <code>v[i]</code>. See examples below</p><ul><li>if <code>v</code> is any other type (any scalar type), then <code>k</code> is set directly to <code>v</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia"># set marker color on first two traces to be red
restyle!(p, [1, 2], marker_color=&quot;red&quot;)

# set marker color on trace 1 to be green and trace 2 to be red
restyle!(p, [2, 1], marker_color=[&quot;red&quot;, &quot;green&quot;])

# set marker color on trace 1 to be red. green is not used
restyle!(p, 1, marker_color=[&quot;red&quot;, &quot;green&quot;])

# set the first marker on trace 1 to red, the second marker on trace 1 to green
restyle!(p, 1, marker_color=([&quot;red&quot;, &quot;green&quot;],))

# suppose p has 3 traces.
# sets marker color on trace 1 to [&quot;red&quot;, &quot;green&quot;]
# sets marker color on trace 2 to &quot;blue&quot;
# sets marker color on trace 3 to [&quot;red&quot;, &quot;green&quot;]
restyle!(p, 1:3, marker_color=([&quot;red&quot;, &quot;green&quot;], &quot;blue&quot;))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.restyle!" href="#PlotlyBase.restyle!"><code>PlotlyBase.restyle!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">restyle!(::Plot, ::AbstractVector{Int}, ::AbstractDict=Dict(); kwargs...)</code></pre><p>Update specific traces at <code>p.data[inds]</code> using update dict and/or kwargs</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.restyle!" href="#PlotlyBase.restyle!"><code>PlotlyBase.restyle!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">restyle!(p::Plot, update::AbstractDict=Dict(); kwargs...)</code></pre><p>Update all traces using update dict and/or kwargs</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.restyle!" href="#PlotlyBase.restyle!"><code>PlotlyBase.restyle!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">restyle!(gt::GenericTrace, i::Int=1, update::AbstractDict=Dict(); kwargs...)</code></pre><p>Update trace <code>gt</code> using dict/kwargs, assuming it was the <code>i</code>th ind in a call to <code>restyle!(::Plot, ...)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.restyle!" href="#PlotlyBase.restyle!"><code>PlotlyBase.restyle!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">restyle!(p::Plot, ind::Int=1, update::AbstractDict=Dict(); kwargs...)</code></pre><p>Update <code>p.data[ind]</code> using update dict and/or kwargs</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.savefig-Tuple{IO,Plot}" href="#PlotlyBase.savefig-Tuple{IO,Plot}"><code>PlotlyBase.savefig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">savefig(
    io::IO,
    p::Plot;
    width::Union{Nothing,Int}=nothing,
    height::Union{Nothing,Int}=nothing,
    scale::Union{Nothing,Real}=nothing,
    format::String=&quot;png&quot;
)</code></pre><p>Save a plot <code>p</code> to the io stream <code>io</code>. They keyword argument <code>format</code> determines the type of data written to the figure and must be one of png, jpeg, webp, svg, pdf, eps, json, or html. <code>scale</code> sets the image scale. <code>width</code> and <code>height</code> set the dimensions, in pixels. Defaults are taken from <code>p.layout</code>, or supplied by plotly</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.savefig-Tuple{Plot,AbstractString}" href="#PlotlyBase.savefig-Tuple{Plot,AbstractString}"><code>PlotlyBase.savefig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">savefig(
    p::Plot, fn::AbstractString;
    format::Union{Nothing,String}=nothing,
    width::Union{Nothing,Int}=nothing,
    height::Union{Nothing,Int}=nothing,
    scale::Union{Nothing,Real}=nothing,
)</code></pre><p>Save a plot <code>p</code> to a file named <code>fn</code>. If <code>format</code> is given and is one of png, jpeg, webp, svg, pdf, eps, json, or html; it will be the format of the file. By default the format is guessed from the extension of <code>fn</code>. <code>scale</code> sets the image scale. <code>width</code> and <code>height</code> set the dimensions, in pixels. Defaults are taken from <code>p.layout</code>, or supplied by plotly</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.sizes" href="#PlotlyBase.sizes"><code>PlotlyBase.sizes</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given the number of rows and columns, return an NTuple{4,Float64} containing <code>(width, height, vspace, hspace)</code>, where <code>width</code> and <code>height</code> are the width and height of each subplot and <code>vspace</code> and <code>hspace</code> are the vertical and horizonal spacing between subplots, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.stem-Tuple{}" href="#PlotlyBase.stem-Tuple{}"><code>PlotlyBase.stem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stem(; y, stem_color, stem_thickness, kwargs...)
</code></pre><p>Creates a &quot;stem&quot; or &quot;lollipop&quot; trace. It is implemented using plotly.js&#39;s <code>scatter</code> type, using the error bars to draw the stem.</p><p><strong>Keyword Arguments:</strong></p><ul><li>All properties accepted by <code>scatter</code> except <code>error_y</code>, which is used to draw   the stems</li><li>stem_color - sets the color of the stems</li><li>stem_thickness - sets the thickness of the stems</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.trace_map" href="#PlotlyBase.trace_map"><code>PlotlyBase.trace_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trace_map(p::Plot, axis::Symbol=:x)</code></pre><p>Return an array of <code>length(p.data)</code> that maps each element of <code>p.data</code> into an integer for which number axis of kind <code>axis</code> that trace belogs to. <code>axis</code> can either be <code>x</code> or <code>y</code>. If <code>x</code> is given, return the integer for which x-axis the trace belongs to. Similar for <code>y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.update!" href="#PlotlyBase.update!"><code>PlotlyBase.update!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Apply both <code>restyle!</code> and <code>relayout!</code> to the plot. Layout arguments are specified by passing an instance of <code>Layout</code> to the <code>layout</code> keyword argument.</p><p>The <code>update</code> Dict (optional) and all keyword arguments will be passed to restyle</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; p = Plot([scatter(y=[1, 2, 3])], Layout(yaxis_title=&quot;this is y&quot;));

julia&gt; print(json(p, 2))
{
  &quot;layout&quot;: {
    &quot;margin&quot;: {
      &quot;l&quot;: 50,
      &quot;b&quot;: 50,
      &quot;r&quot;: 50,
      &quot;t&quot;: 60
    },
    &quot;yaxis&quot;: {
      &quot;title&quot;: &quot;this is y&quot;
    }
  },
  &quot;data&quot;: [
    {
      &quot;y&quot;: [
        1,
        2,
        3
      ],
      &quot;type&quot;: &quot;scatter&quot;
    }
  ]
}

julia&gt; update!(p, Dict(:marker =&gt; Dict(:color =&gt; &quot;red&quot;)), layout=Layout(title=&quot;this is a title&quot;), marker_symbol=&quot;star&quot;);

julia&gt; print(json(p, 2))
{
  &quot;layout&quot;: {
    &quot;margin&quot;: {
      &quot;l&quot;: 50,
      &quot;b&quot;: 50,
      &quot;r&quot;: 50,
      &quot;t&quot;: 60
    },
    &quot;yaxis&quot;: {
      &quot;title&quot;: &quot;this is y&quot;
    },
    &quot;title&quot;: &quot;this is a title&quot;
  },
  &quot;data&quot;: [
    {
      &quot;y&quot;: [
        1,
        2,
        3
      ],
      &quot;type&quot;: &quot;scatter&quot;,
      &quot;marker&quot;: {
        &quot;color&quot;: &quot;red&quot;,
        &quot;symbol&quot;: &quot;star&quot;
      }
    }
  ]
}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.vline" href="#PlotlyBase.vline"><code>PlotlyBase.vline</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>vline(x, fields::AbstractDict=Dict{Symbol,Any}(); kwargs...)</code></p><p>Draw vertical lines at each point in <code>x</code> that span the height of the plot</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.GenericTrace-Tuple{AbstractDataFrame,Symbol,Symbol}" href="#PlotlyBase.GenericTrace-Tuple{AbstractDataFrame,Symbol,Symbol}"><code>PlotlyBase.GenericTrace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GenericTrace(df, x, y; kwargs...)
</code></pre><p>Pass the provided values of <code>x</code> and <code>y</code> as keyword arguments for constructing the trace from <code>df</code>. See other method for more information</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.GenericTrace-Tuple{AbstractDataFrame,Symbol}" href="#PlotlyBase.GenericTrace-Tuple{AbstractDataFrame,Symbol}"><code>PlotlyBase.GenericTrace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GenericTrace(df, y; kwargs...)
</code></pre><p>Pass the provided value <code>y</code> as keyword argument for constructing the trace from <code>df</code>. See other method for more information</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.GenericTrace-Tuple{AbstractDataFrame}" href="#PlotlyBase.GenericTrace-Tuple{AbstractDataFrame}"><code>PlotlyBase.GenericTrace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GenericTrace(df; group, kind, kwargs...)
</code></pre><p>Build a trace of kind <code>kind</code>, using the columns of <code>df</code> where possible. In particular for all keyword arguments, if the value of the keyword argument is a Symbol and matches one of the column names of <code>df</code>, replace the value of the keyword argument with the column of <code>df</code></p><p>If <code>group</code> is passed and is a Symbol that is one of the column names of <code>df</code>, then call <code>by(df, group)</code> and construct one trace per SubDataFrame, passing all other keyword arguments. This means all keyword arguments are passed applied to all traces</p><p>Also, when using this routine you can pass a function as a value for any keyword argument. This function will be replaced by calling the function on the DataFrame. For example, if I were to pass <code>name=(df) -&gt; &quot;Wage (average = $(mean(df[!, :X1])))&quot;</code> then the <code>name</code> attribute on the trace would be replaced by the  <code>Wage (average = XX)</code>, where <code>XX</code> is the average of the <code>X1</code> column in the DataFrame.</p><p>The ability to pass functions as values for keyword arguments is particularly useful when using the <code>group</code> keyword arugment, as the function will be applied to each SubDataFrame. In the example above, the name attribute would set a different mean for each group.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.Plot" href="#PlotlyBase.Plot"><code>PlotlyBase.Plot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Plot(d, y)
Plot(d, y, l; style, kwargs...)
</code></pre><p>Construct a plot from <code>df</code>, passing the provided value y as a keyword argument. See docstring for other method for more information.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.Plot" href="#PlotlyBase.Plot"><code>PlotlyBase.Plot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Plot(fs, x0, x1)
Plot(fs, x0, x1, l; style, kwargs...)
</code></pre><p>For each function in <code>f</code> in <code>fs</code>, construct a scatter trace that plots <code>f</code> from <code>x0</code> to <code>x1</code>, using the layout <code>l</code>. All keyword arguments are applied to all constructed traces.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.Plot" href="#PlotlyBase.Plot"><code>PlotlyBase.Plot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Plot(d, x, y)
Plot(d, x, y, l; style, kwargs...)
</code></pre><p>Construct a plot from <code>df</code>, passing the provided values of x and y as keyword arguments. See docstring for other method for more information.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.Plot" href="#PlotlyBase.Plot"><code>PlotlyBase.Plot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Plot(df)
Plot(df, l; style, kwargs...)
</code></pre><p>Construct a plot using the columns of <code>df</code> if possible. For each keyword argument, if the value of the argument is a Symbol and the <code>df</code> has a column whose name matches the value, replace the value with the column of the <code>df</code>.</p><p>If <code>group</code> is passed and is a Symbol that is one of the column names of <code>df</code>, then call <code>by(df, group)</code> and construct one trace per SubDataFrame, passing all other keyword arguments. This means all keyword arguments are passed applied to all traces</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.Plot" href="#PlotlyBase.Plot"><code>PlotlyBase.Plot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Plot(f, x0, x1)
Plot(f, x0, x1, l; style, kwargs...)
</code></pre><p>Construct a plot of <code>f</code> from <code>x0</code> to <code>x1</code>, using the layout <code>l</code>. All keyword arguments are applied to the constructed trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.Plot-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Layout}} where T&lt;:Union{Date, DateTime, AbstractString, Number, Symbol}" href="#PlotlyBase.Plot-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Layout}} where T&lt;:Union{Date, DateTime, AbstractString, Number, Symbol}"><code>PlotlyBase.Plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Plot(y)
Plot(y, l; kwargs...)
</code></pre><p>Build a scatter plot and set  <code>y</code> to y. All keyword arguments are passed directly as keyword arguments to the constructed scatter.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.Plot-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1} where T}, Tuple{AbstractArray{T,1},AbstractArray{T,1} where T,Layout}} where T&lt;:Union{Date, DateTime, AbstractString, Number, Symbol}" href="#PlotlyBase.Plot-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1} where T}, Tuple{AbstractArray{T,1},AbstractArray{T,1} where T,Layout}} where T&lt;:Union{Date, DateTime, AbstractString, Number, Symbol}"><code>PlotlyBase.Plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Plot(x, y)
Plot(x, y, l; kind, style, kwargs...)
</code></pre><p>Build a plot of with one trace of type <code>kind</code>and set <code>x</code> to x and <code>y</code> to y. All keyword arguments are passed directly as keyword arguments to the constructed trace.</p><p><strong>NOTE</strong>: If <code>y</code> is a matrix, one trace is constructed for each column of <code>y</code></p><p><strong>NOTE</strong>: If <code>x</code> and <code>y</code> are both matrices, they must have the same number of columns (say <code>N</code>). Then <code>N</code> traces are constructed, where the <code>i</code>th column of <code>x</code> is paired with the <code>i</code>th column of <code>y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PlotlyBase.savehtml" href="#PlotlyBase.savehtml"><code>PlotlyBase.savehtml</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PlotlyBase.savehtml(io::IO, p::Union{Plot,SyncPlot}, js::Symbol=js_default[])
PlotlyBase.savehtml(p::Union{Plot,SyncPlot}, fn::AbstractString, js::Symbol=js_default[])</code></pre><p>Save plot to standalone html file suitable for including in a website or opening in a browser</p><p>Can either be written to an arbitrary IO stream, or saved to a file noted with a string <code>fn</code>.</p><p>The <code>js</code> argument can be one of</p><ul><li><code>:local</code>: Reference the local plotly.js file included in this Julia package   Pros: small file size, offline viewing. Cons: Can&#39;t share with others or   move to different machine..</li><li><code>:remote</code>: Reference plotly.js from a CDN. Pros small file size, move to   other machine. Cons: need internet access to fetch from CDN</li><li><code>:embed</code>: Embed the entirety of your local copy of plotly.js in the   outputted file. Pros: offline viewing, move to other machine. Con: large   file size (adds about 2.7 MB)</li></ul><p>The default is <code>:local</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/PlotlyJS.jl/blob/54b3ec01738ddf93ad320c62d8bb653b216b480a/src/display.jl#L367-L389">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/violin/">« Violin</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 20 August 2020 19:47">Thursday 20 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
